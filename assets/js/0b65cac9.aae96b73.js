"use strict";(self.webpackChunkcosmos_hub_docs_site=self.webpackChunkcosmos_hub_docs_site||[]).push([[8070],{3235:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"architecture/adr/adr-002-globalfee","title":"ADR 002: Globalfee Module [DEPRECATED]","description":"Changelog","source":"@site/docs/architecture/adr/adr-002-globalfee.md","sourceDirName":"architecture/adr","slug":"/architecture/adr/adr-002-globalfee","permalink":"/main/architecture/adr/adr-002-globalfee","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"adr-001-interchain-accounts","permalink":"/main/architecture/adr/adr-001-interchain-accounts"},"next":{"title":"ADR 003: Interchain Accounts Controller Module","permalink":"/main/architecture/adr/adr-003-ica-controller"}}');var i=s(2467),r=s(8453);const c={},t="ADR 002: Globalfee Module [DEPRECATED]",d={},a=[{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"ZeroCoins in <code>MinimumGasPricesParam</code>",id:"zerocoins-in-minimumgaspricesparam",level:3},{value:"Coins Split",id:"coins-split",level:4},{value:"Fee Checks",id:"fee-checks",level:4},{value:"Bypass Message Types",id:"bypass-message-types",level:3},{value:"Fee Checks in <code>DeliverTx</code>",id:"fee-checks-in-delivertx",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3}];function l(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"adr-002-globalfee-module-deprecated",children:"ADR 002: Globalfee Module [DEPRECATED]"})}),"\n",(0,i.jsx)(n.h2,{id:"changelog",children:"Changelog"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"2023-06-12: Initial Draft"}),"\n",(0,i.jsx)(n.li,{children:"2024-06-06: Change status to deprecated"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,i.jsx)(n.p,{children:"Deprecated"}),"\n",(0,i.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,i.jsxs)(n.p,{children:["The globalfee module was created to manage a parameter called ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"}),", which sets a network-wide minimum fee requirement. The intention was to stop random denominations from entering fee collections and to reduce the time validators take to check a long list of transaction fees. To address scenarios where no fee payment is required but the denominations for volunteered paid fees are still restricted, the zero coins was introduced to serve as a means of limiting the denoms. Nevertheless, the initial version of the globalfee module had some issues:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["In the globalfee module, several Cosmos SDK coins methods were redefined because of the allowance of zero-value coins in the ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"}),". The ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"})," is of ",(0,i.jsx)(n.code,{children:"sdk.DecCoins"})," type. In the Cosmos SDK, ",(0,i.jsx)(n.code,{children:"sdk.DecCoins"})," are ",(0,i.jsx)(n.a,{href:"https://github.com/cosmos/cosmos-sdk/blob/67f04e629623d4691c4b2e48806f7793a3aa211e/types/dec_coin.go#L160-L177",children:"sanitized"})," to remove zero-value coins. As a result, several methods from ",(0,i.jsx)(n.code,{children:"sdk.Coins"})," were ",(0,i.jsx)(n.a,{href:"https://github.com/cosmos/gaia/blob/890ab3aa2e5788537b0d2ebc9bafdc968340e0e5/x/globalfee/ante/fee_utils.go#L46-L104",children:"redefined in the Gaia fee antehandler"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"BypassMinFeeMsgTypes"})," exists in ",(0,i.jsx)(n.code,{children:"app.toml"}),", which means each node can define its own value. Thus, it's not clear whether a transaction containing bypass-messages will be exempted from paying a fee."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The fee check logic is only executed in ",(0,i.jsx)(n.code,{children:"CheckTx"}),". This could enable malicious validators to change the fee check code and propose transactions that do not meet the fee requirement."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsx)(n.p,{children:"To fix these problems, the following changes are added to the globalfee module:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["ZeroCoins in ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"}),":"]}),(0,i.jsx)(n.br,{}),"\n","Refactor the fee check logics, in order to use the Cosmos SDK coins' methods instead of the redefined methods."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bypass Message Types:"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.code,{children:"BypassMinFeeMsgTypes"})," is refactored to be a param of the globalfee module, in order to make the bypass messages deterministic."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Check Fees in ",(0,i.jsx)(n.code,{children:"DeliverTx"}),":"]}),(0,i.jsx)(n.br,{}),"\n","The fee check is factored to executed in both ",(0,i.jsx)(n.code,{children:"DeliverTx"})," and ",(0,i.jsx)(n.code,{children:"CheckTx"}),". This is to prevent malicious validators from changing the fee check logic and allowing any transactions to pass fee check. As a consequence, ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"})," is introduced as a globalfee param."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"zerocoins-in-minimumgaspricesparam",children:["ZeroCoins in ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"})]}),"\n",(0,i.jsx)(n.h4,{id:"coins-split",children:"Coins Split"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CombinedFeeRequirement"})," refers to the fee requirement that takes into account both ",(0,i.jsx)(n.code,{children:"globalFees"})," (",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"})," in the globalfee module) and ",(0,i.jsx)(n.code,{children:"localFees"})," (",(0,i.jsx)(n.code,{children:"minimum-gas-prices"})," in ",(0,i.jsx)(n.code,{children:"app.toml"}),"). This requirement is calculated as the maximum value between ",(0,i.jsx)(n.code,{children:"globalFees"})," and ",(0,i.jsx)(n.code,{children:"localFees"})," for denomination exists ",(0,i.jsx)(n.code,{children:"globalFees"}),".\nThe allowance of zero coins in the ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"})," within the globalfee module implies that ",(0,i.jsx)(n.code,{children:"CombinedFeeRequirement(globalFees, localFees)"})," also permits zero coins. Therefore, the ",(0,i.jsx)(n.code,{children:"CombinedFeeRequirement"})," doesn't meet the requirements of certain ",(0,i.jsx)(n.code,{children:"sdk.Coins"})," methods. For instance, the ",(0,i.jsx)(n.code,{children:"DenomsSubsetOf"})," method requires coins that do not contain zero coins."]}),"\n",(0,i.jsxs)(n.p,{children:["To address this issue, the ",(0,i.jsx)(n.code,{children:"CombinedFeeRequirement"})," and ",(0,i.jsx)(n.code,{children:"feeCoins"})," are split as shown in the chart below."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"---\ntitle: Fee Requirements and Fee Splits\n---\nflowchart TD\n\tsubgraph feeReq\n    A[CombinedFeeRequirement]--\x3eB[/Split zero/nonzero coins/]\n    B--\x3e|zero coins| C[zeroCoinFeesDenomReq];\n\tB--\x3e|nonzero coins| D[nonzeroCoinFeesDenomReq];\n\n\tend\n\n\tsubgraph feeCoin\n\tE[feeCoins]--\x3eF[/Split by the denoms in zero/nonzero CoinFeesDenomReq/]\n    F--\x3e|denoms in zeroCoinFeesDenomReq set| G[feeCoinsZeroDenom]\n    F--\x3e|denoms in nonzeroCoinFeesDenomReq set| H[feeCoinsNonZeroDenom]\n\tend\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"CombinedFeeRequirement"})," is split into zero and non-zero coins, forming ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq"})," and ",(0,i.jsx)(n.code,{children:"zeroCoinFeesDenomReq"}),". Similarly, the paid fees (feeCoins) are split into ",(0,i.jsx)(n.code,{children:"feeCoinsNonZeroDenom"})," and ",(0,i.jsx)(n.code,{children:"feeCoinsZeroDenom"}),", based on the denominations of ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq"})," and ",(0,i.jsx)(n.code,{children:"zeroCoinFeesDenomReq"})," as shown in the following code snippet."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"\tnonZeroCoinFeesReq, zeroCoinFeesDenomReq := getNonZeroFees(feeRequired)\n\n\t// feeCoinsNonZeroDenom contains non-zero denominations from the feeRequired\n\t// feeCoinsNonZeroDenom is used to check if the fees meets the requirement imposed by nonZeroCoinFeesReq\n\t// when feeCoins does not contain zero coins' denoms in feeRequired\n\tfeeCoinsNonZeroDenom, feeCoinsZeroDenom := splitCoinsByDenoms(feeCoins, zeroCoinFeesDenomReq)\n\n"})}),"\n",(0,i.jsx)(n.h4,{id:"fee-checks",children:"Fee Checks"}),"\n",(0,i.jsx)(n.p,{children:"The Workflow of feeCheck is shown below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"---\ntitle: Fee Check\n---\nflowchart TD\n\nA[feeCoinsNonZeroDenom]--\x3eB[/DenomsSubsetOf_nonZeroCoinFeesReq/];\nB--\x3e|yes|C[is_bypass_msg];\nB--\x3e|no|D((reject));\n\nC--\x3e|yes|pass1((pass));\nC--\x3e|no|D[/contain_zeroCoinFeesDenomReq_denom/];\n\nD--\x3e|yes|pass2((pass));\nD--\x3e|no|E[/feeCoinsZeroDenom_nonEmpty/];\n\n\nE--\x3e|yes|pass3((pass));\nE--\x3e|no|F[/IsAnyGTE_nonZeroCoinFeesDenomReq/];\n\nF--\x3e|yes|pass4((pass));\nF--\x3e|no|reject2((reject));\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The split enable checking ",(0,i.jsx)(n.code,{children:"feeCoinsNonZeroDenom"})," against ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq"}),", and ",(0,i.jsx)(n.code,{children:"feeCoinsZeroDenom"})," against\n",(0,i.jsx)(n.code,{children:"zeroCoinFeesDenomReq"})," (as shown in the following code snippet). In the check of ",(0,i.jsx)(n.code,{children:"feeCoinsNonZeroDenom"})," against ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq"}),", the Cosmos SDK coins' methods can be used since zero coins are removed from the ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq"}),", while in the check ",(0,i.jsx)(n.code,{children:"feeCoinsZeroDenom"})," against ",(0,i.jsx)(n.code,{children:"zeroCoinFeesDenomReq"}),", only denoms need to be checked."]}),"\n",(0,i.jsxs)(n.p,{children:["Checking ",(0,i.jsx)(n.code,{children:"feeCoinsNonZeroDenom"})," against ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'\tif !feeCoinsNonZeroDenom.IsAnyGTE(nonZeroCoinFeesReq) {\n\t\treturn ctx, sdkerrors.Wrapf(sdkerrors.ErrInsufficientFee, "insufficient fees; got: %s required: %s", feeCoins.String(), feeRequired.String())\n\t}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here is an example of how the coins split and checked in fee antehandler:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"assumption"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"globalfee=[1photon, 0uatom, 1stake]"})," and ",(0,i.jsx)(n.code,{children:"local min-gas-prices=[0.5stake]"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"fee requirement"}),":"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"combinedFeeRequirement=[1photon, 0uatom, 1stake]"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"split fee requirement"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["the ",(0,i.jsx)(n.code,{children:"combinedFeeRequirement"})," into ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq=[0uatom]"}),", and ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq=[1photon, 1stake]"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"split the paid fees"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["if ",(0,i.jsx)(n.code,{children:"paidFee=[1uatom, 0.5photon]"}),",\nthe ",(0,i.jsx)(n.code,{children:"splitCoinsByDenoms"})," splits the paidFee into ",(0,i.jsx)(n.code,{children:"feeCoinsZeroDenom=[1uatom]"})," (the same denom as zero coins in ",(0,i.jsx)(n.code,{children:"combinedFeeRequirement"}),"), and ",(0,i.jsx)(n.code,{children:"feeCoinsNonZeroDenom=[0.5stake]"}),"\nthen ",(0,i.jsx)(n.code,{children:"feeCoinsZeroDenom=[1uatom]"})," is checked by ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesReq=[1photon, 1stake]"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Please note that ",(0,i.jsx)(n.code,{children:"feeCoins"})," does not contain zero coins. The fee coins are split according to the denoms in ",(0,i.jsx)(n.code,{children:"zeroCoinFeesDenomReq"})," or ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesDenomReq"}),". If feeCoins contains coins not in both ",(0,i.jsx)(n.code,{children:"zeroCoinFeesDenomReq"})," and ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesDenomReq"}),", the transaction should be rejected. On the contrary, if feeCoins' denoms are in either ",(0,i.jsx)(n.code,{children:"zeroCoinFeesDenomReq"})," or ",(0,i.jsx)(n.code,{children:"nonZeroCoinFeesDenomReq"}),", and ",(0,i.jsx)(n.code,{children:"len(zeroCoinFeesDenomReq)!=0"}),", the transaction can directly pass, otherwise, the fee amount need to be checked."]}),"\n",(0,i.jsx)(n.h3,{id:"bypass-message-types",children:"Bypass Message Types"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"BypassMinFeeMsgTypes"})," was a setup in ",(0,i.jsx)(n.code,{children:"config/app.toml"})," before the refactor. ",(0,i.jsx)(n.code,{children:"BypassMinFeeMsgTypes"})," is refactored to be a param of the globalfee module to get a network level agreement. Correspondingly,",(0,i.jsx)(n.code,{children:"MaxTotalBypassMinFeeMsgGasUsage"})," is also introduced as a globalfee param."]}),"\n",(0,i.jsxs)(n.h3,{id:"fee-checks-in-delivertx",children:["Fee Checks in ",(0,i.jsx)(n.code,{children:"DeliverTx"})]}),"\n",(0,i.jsxs)(n.p,{children:["Implementing fee checks within the ",(0,i.jsx)(n.code,{children:"DeliverTx"})," function introduces a few requirements:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deterministic Minimum Fee Requirement"}),": For the ",(0,i.jsx)(n.code,{children:"DeliverTx"})," process, it is essential to have a deterministic minimum fee requirement. In ",(0,i.jsx)(n.code,{children:"CheckTx"}),", fee is checked by the ",(0,i.jsx)(n.code,{children:"CombinedFeeRequirement(globalFees, localFees)"}),", which considers both ",(0,i.jsx)(n.code,{children:"minimum-gas-prices"})," from ",(0,i.jsx)(n.code,{children:"config/app.toml"})," and ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"})," from the globalfee Params (For more details, see ",(0,i.jsx)(n.a,{href:"https://github.com/cosmos/gaia/blob/v16.0.0/docs/docs/modules/globalfee.md",children:"globalfee"}),"). ",(0,i.jsx)(n.code,{children:"CombinedFeeRequirement"})," contains non-deterministic part: ",(0,i.jsx)(n.code,{children:"minimum-gas-prices"})," from ",(0,i.jsx)(n.code,{children:"app.toml"}),". Therefore, ",(0,i.jsx)(n.code,{children:"CombinedFeeRequirement"})," cannot be used in ",(0,i.jsx)(n.code,{children:"DeliverTx"}),". In ",(0,i.jsx)(n.code,{children:"DeliverTx"}),", only ",(0,i.jsx)(n.code,{children:"MinimumGasPricesParam"})," in globalfee Params is used for fee verification. The code implementation is shown below."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func (mfd FeeDecorator) GetTxFeeRequired(ctx sdk.Context, tx sdk.FeeTx) (sdk.Coins, error) {\n\t// Get required global fee min gas prices\n\t// Note that it should never be empty since its default value is set to coin={"StakingBondDenom", 0}\n\tglobalFees, err := mfd.GetGlobalFee(ctx, tx)\n\tif err != nil {\n\t\treturn sdk.Coins{}, err\n\t}\n\n\t// In DeliverTx, the global fee min gas prices are the only tx fee requirements.\n\tif !ctx.IsCheckTx() {\n\t\treturn globalFees, nil\n\t}\n\n\t// In CheckTx mode, the local and global fee min gas prices are combined\n\t// to form the tx fee requirements\n\n\t// Get local minimum-gas-prices\n\tlocalFees := GetMinGasPrice(ctx, int64(tx.GetGas()))\n\n\t// Return combined fee requirements\n\treturn CombinedFeeRequirement(globalFees, localFees)\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Deterministic Bypass Parameters"}),": The decision of whether a message can bypass the minimum fee has to be deterministic as well. To ensure this, ",(0,i.jsx)(n.code,{children:"BypassMinFeeMsgTypes"})," and ",(0,i.jsx)(n.code,{children:"MaxTotalBypassMinFeeMsgGasUsage"})," parameters are moved to a persistent store."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Module Initialization Order"}),": The genutils module must be initialized before the globalfee module. This is due to the ",(0,i.jsx)(n.code,{children:"DeliverGenTxs"})," in the genutils module, is called during ",(0,i.jsx)(n.code,{children:"initGenesis"}),". This function executes ",(0,i.jsx)(n.code,{children:"DeliverTx"}),", which subsequently calls the AnteHandle in FeeDecorator, triggering the fee check in ",(0,i.jsx)(n.code,{children:"DeliverTx"}),".\nTo prevent the ",(0,i.jsx)(n.code,{children:"DeliverGenTxs"})," go through a fee check, the initialization of the globalfee module should occur after the genutils module. This sequencing ensures that all necessary components are in place when the fee check occurs. See ",(0,i.jsx)(n.a,{href:"https://github.com/cosmos/gaia/issues/2489",children:"Gaia Issue #2489"})," for more context."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsx)(n.h3,{id:"positive",children:"Positive"}),"\n",(0,i.jsx)(n.p,{children:"This refactor results in code that is easier to maintain. It prevents malicious validators from escaping fee checks and make the bypass messages work at network level."}),"\n",(0,i.jsx)(n.h3,{id:"negative",children:"Negative"}),"\n",(0,i.jsxs)(n.p,{children:["The introduction of FeeDecorator has replaced the usage of ",(0,i.jsx)(n.code,{children:"MempoolFeeDecorator"})," in the Cosmos SDK. Currently, if both FeeDecorator and MempoolFeeDecorator are added to the AnteDecorator chain, it will result in redundant checks. However, there's potential for FeeDecorator and MempoolFeeDecorator to become incompatible in the future, depending on updates to the Cosmos SDK."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>t});var o=s(6540);const i={},r=o.createContext(i);function c(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);