"use strict";(self.webpackChunkcosmos_hub_docs_site=self.webpackChunkcosmos_hub_docs_site||[]).push([[6331],{5724:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"hub-tutorials/live-upgrade-tutorial","title":"Upgrading the Chain","description":"This document demonstrates how a live upgrade can be performed on-chain through a","source":"@site/docs/hub-tutorials/live-upgrade-tutorial.md","sourceDirName":"hub-tutorials","slug":"/hub-tutorials/live-upgrade-tutorial","permalink":"/main/hub-tutorials/live-upgrade-tutorial","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Upgrading the Chain","order":6},"sidebar":"tutorialSidebar","previous":{"title":"Joining Testnet","permalink":"/main/hub-tutorials/join-testnet"},"next":{"title":"Upgrading Your Node","permalink":"/main/hub-tutorials/upgrade-node"}}');var r=a(2467),o=a(8453);const i={title:"Upgrading the Chain",order:6},s=void 0,d={},l=[];function p(e){const n={code:"code",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This document demonstrates how a live upgrade can be performed on-chain through a\ngovernance process."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Start the network and trigger upgrade"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# start a gaia application full-node\n$ gaiad start\n\n# set up the cli config\n$ gaiad config chain-id testing\n\n# create an upgrade governance proposal\n$ gaiad tx gov submit-proposal  <path-to-proposal-json> --from <name-or-key>\n\nWhere proposal json file contains MsgSoftwareUpgrade e.g.\n`{\n \t"messages": [\n \t {\n \t  "@type": "/cosmos.upgrade.v1beta1.MsgSoftwareUpgrade",\n \t  "authority":"cosmos10d07y265gmmuvt4z0w9aw880jnsr700j6zn9kn" ,\n \t  "plan": {\n \t   "name": "plan name",\n \t   "height": "1000" ,\n \t   "info": "proposal info" ,\n \t   "upgraded_client_state": null\n \t  }\n \t }\n \t],\n \t"metadata": "ipfs://CID",\n \t"deposit": "10000000stake",\n \t"title": "proposal title",\n \t"summary": "proposal summary"\n }`\n\n\n# once the proposal passes you can query the pending plan\n$ gaiad query upgrade plan\n'})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Performing an upgrade"}),"\n",(0,r.jsx)(n.p,{children:"Assuming the proposal passes the chain will stop at given upgrade height."}),"\n",(0,r.jsxs)(n.p,{children:["You can stop and start the original binary all you want, but ",(0,r.jsx)(n.strong,{children:"it will refuse to\nrun after the upgrade height"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"We need a new binary with the upgrade handler installed. The logs should look\nsomething like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'E[2019-11-05|12:44:18.913] UPGRADE "<plan-name>" NEEDED at height: <desired-upgrade-height>:       module=main\nE[2019-11-05|12:44:18.914] CONSENSUS FAILURE!!!\n...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Note that the process will hang indefinitely (doesn't exit to avoid restart loops). So, you must\nmanually kill the process and replace it with a new binary. Do so now with ",(0,r.jsx)(n.code,{children:"Ctrl+C"})," or ",(0,r.jsx)(n.code,{children:"killall gaiad"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.code,{children:"gaia/app/app.go"}),", after ",(0,r.jsx)(n.code,{children:"upgrade.Keeper"})," is initialized and set in the app, set the\ncorresponding upgrade ",(0,r.jsx)(n.code,{children:"Handler"})," with the correct ",(0,r.jsx)(n.code,{children:"<plan-name>"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'    app.upgradeKeeper.SetUpgradeHandler("<plan-name>", func(ctx sdk.Context, plan upgrade.Plan) {\n        // custom logic after the network upgrade has been executed\n    })\n'})}),"\n",(0,r.jsx)(n.p,{children:"Note that we panic on any error - this would cause the upgrade to fail if the\nmigration could not be run, and no node would advance - allowing a manual recovery.\nIf we ignored the errors, then we would proceed with an incomplete upgrade and\nhave a very difficult time every recovering the proper state."}),"\n",(0,r.jsx)(n.p,{children:"Now, compile the new binary and run the upgraded code to complete the upgrade:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# create a new binary of gaia with the added upgrade handler\n$ make install\n\n# Restart the chain using the new binary. You should see the chain resume from\n# the upgrade height:\n# `I[2019-11-05|12:48:15.184] applying upgrade <plan-name> at height: <desired-upgrade-height>      module=main`\n$ gaiad start\n\n# verify there is no pending plan\n$ gaiad query upgrade plan\n\n# verify you can query the block header of the completed upgrade\n$ gaiad query upgrade applied <plan-name>\n"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>s});var t=a(6540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);