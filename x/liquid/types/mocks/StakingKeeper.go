// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	address "cosmossdk.io/core/address"

	cosmos_sdktypes "github.com/cosmos/cosmos-sdk/types"

	math "cosmossdk.io/math"

	mock "github.com/stretchr/testify/mock"

	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

// StakingKeeper is an autogenerated mock type for the StakingKeeper type
type StakingKeeper struct {
	mock.Mock
}

type StakingKeeper_Expecter struct {
	mock *mock.Mock
}

func (_m *StakingKeeper) EXPECT() *StakingKeeper_Expecter {
	return &StakingKeeper_Expecter{mock: &_m.Mock}
}

// BondDenom provides a mock function with given fields: ctx
func (_m *StakingKeeper) BondDenom(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BondDenom")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_BondDenom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BondDenom'
type StakingKeeper_BondDenom_Call struct {
	*mock.Call
}

// BondDenom is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StakingKeeper_Expecter) BondDenom(ctx interface{}) *StakingKeeper_BondDenom_Call {
	return &StakingKeeper_BondDenom_Call{Call: _e.mock.On("BondDenom", ctx)}
}

func (_c *StakingKeeper_BondDenom_Call) Run(run func(ctx context.Context)) *StakingKeeper_BondDenom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StakingKeeper_BondDenom_Call) Return(_a0 string, _a1 error) *StakingKeeper_BondDenom_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StakingKeeper_BondDenom_Call) RunAndReturn(run func(context.Context) (string, error)) *StakingKeeper_BondDenom_Call {
	_c.Call.Return(run)
	return _c
}

// Delegate provides a mock function with given fields: ctx, delAddr, bondAmt, tokenSrc, validator, subtractAccount
func (_m *StakingKeeper) Delegate(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, bondAmt math.Int, tokenSrc stakingtypes.BondStatus, validator stakingtypes.Validator, subtractAccount bool) (math.LegacyDec, error) {
	ret := _m.Called(ctx, delAddr, bondAmt, tokenSrc, validator, subtractAccount)

	if len(ret) == 0 {
		panic("no return value specified for Delegate")
	}

	var r0 math.LegacyDec
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, math.Int, stakingtypes.BondStatus, stakingtypes.Validator, bool) (math.LegacyDec, error)); ok {
		return rf(ctx, delAddr, bondAmt, tokenSrc, validator, subtractAccount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, math.Int, stakingtypes.BondStatus, stakingtypes.Validator, bool) math.LegacyDec); ok {
		r0 = rf(ctx, delAddr, bondAmt, tokenSrc, validator, subtractAccount)
	} else {
		r0 = ret.Get(0).(math.LegacyDec)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.AccAddress, math.Int, stakingtypes.BondStatus, stakingtypes.Validator, bool) error); ok {
		r1 = rf(ctx, delAddr, bondAmt, tokenSrc, validator, subtractAccount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_Delegate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delegate'
type StakingKeeper_Delegate_Call struct {
	*mock.Call
}

// Delegate is a helper method to define mock.On call
//   - ctx context.Context
//   - delAddr cosmos_sdktypes.AccAddress
//   - bondAmt math.Int
//   - tokenSrc stakingtypes.BondStatus
//   - validator stakingtypes.Validator
//   - subtractAccount bool
func (_e *StakingKeeper_Expecter) Delegate(ctx interface{}, delAddr interface{}, bondAmt interface{}, tokenSrc interface{}, validator interface{}, subtractAccount interface{}) *StakingKeeper_Delegate_Call {
	return &StakingKeeper_Delegate_Call{Call: _e.mock.On("Delegate", ctx, delAddr, bondAmt, tokenSrc, validator, subtractAccount)}
}

func (_c *StakingKeeper_Delegate_Call) Run(run func(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, bondAmt math.Int, tokenSrc stakingtypes.BondStatus, validator stakingtypes.Validator, subtractAccount bool)) *StakingKeeper_Delegate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.AccAddress), args[2].(math.Int), args[3].(stakingtypes.BondStatus), args[4].(stakingtypes.Validator), args[5].(bool))
	})
	return _c
}

func (_c *StakingKeeper_Delegate_Call) Return(newShares math.LegacyDec, err error) *StakingKeeper_Delegate_Call {
	_c.Call.Return(newShares, err)
	return _c
}

func (_c *StakingKeeper_Delegate_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.AccAddress, math.Int, stakingtypes.BondStatus, stakingtypes.Validator, bool) (math.LegacyDec, error)) *StakingKeeper_Delegate_Call {
	_c.Call.Return(run)
	return _c
}

// Delegation provides a mock function with given fields: ctx, addrDel, addrVal
func (_m *StakingKeeper) Delegation(ctx context.Context, addrDel cosmos_sdktypes.AccAddress, addrVal cosmos_sdktypes.ValAddress) (stakingtypes.DelegationI, error) {
	ret := _m.Called(ctx, addrDel, addrVal)

	if len(ret) == 0 {
		panic("no return value specified for Delegation")
	}

	var r0 stakingtypes.DelegationI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) (stakingtypes.DelegationI, error)); ok {
		return rf(ctx, addrDel, addrVal)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) stakingtypes.DelegationI); ok {
		r0 = rf(ctx, addrDel, addrVal)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(stakingtypes.DelegationI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) error); ok {
		r1 = rf(ctx, addrDel, addrVal)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_Delegation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delegation'
type StakingKeeper_Delegation_Call struct {
	*mock.Call
}

// Delegation is a helper method to define mock.On call
//   - ctx context.Context
//   - addrDel cosmos_sdktypes.AccAddress
//   - addrVal cosmos_sdktypes.ValAddress
func (_e *StakingKeeper_Expecter) Delegation(ctx interface{}, addrDel interface{}, addrVal interface{}) *StakingKeeper_Delegation_Call {
	return &StakingKeeper_Delegation_Call{Call: _e.mock.On("Delegation", ctx, addrDel, addrVal)}
}

func (_c *StakingKeeper_Delegation_Call) Run(run func(ctx context.Context, addrDel cosmos_sdktypes.AccAddress, addrVal cosmos_sdktypes.ValAddress)) *StakingKeeper_Delegation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.AccAddress), args[2].(cosmos_sdktypes.ValAddress))
	})
	return _c
}

func (_c *StakingKeeper_Delegation_Call) Return(_a0 stakingtypes.DelegationI, _a1 error) *StakingKeeper_Delegation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StakingKeeper_Delegation_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) (stakingtypes.DelegationI, error)) *StakingKeeper_Delegation_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllDelegations provides a mock function with given fields: ctx
func (_m *StakingKeeper) GetAllDelegations(ctx context.Context) ([]stakingtypes.Delegation, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllDelegations")
	}

	var r0 []stakingtypes.Delegation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]stakingtypes.Delegation, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []stakingtypes.Delegation); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]stakingtypes.Delegation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_GetAllDelegations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllDelegations'
type StakingKeeper_GetAllDelegations_Call struct {
	*mock.Call
}

// GetAllDelegations is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StakingKeeper_Expecter) GetAllDelegations(ctx interface{}) *StakingKeeper_GetAllDelegations_Call {
	return &StakingKeeper_GetAllDelegations_Call{Call: _e.mock.On("GetAllDelegations", ctx)}
}

func (_c *StakingKeeper_GetAllDelegations_Call) Run(run func(ctx context.Context)) *StakingKeeper_GetAllDelegations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StakingKeeper_GetAllDelegations_Call) Return(delegations []stakingtypes.Delegation, err error) *StakingKeeper_GetAllDelegations_Call {
	_c.Call.Return(delegations, err)
	return _c
}

func (_c *StakingKeeper_GetAllDelegations_Call) RunAndReturn(run func(context.Context) ([]stakingtypes.Delegation, error)) *StakingKeeper_GetAllDelegations_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllValidators provides a mock function with given fields: ctx
func (_m *StakingKeeper) GetAllValidators(ctx context.Context) ([]stakingtypes.Validator, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllValidators")
	}

	var r0 []stakingtypes.Validator
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]stakingtypes.Validator, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []stakingtypes.Validator); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]stakingtypes.Validator)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_GetAllValidators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllValidators'
type StakingKeeper_GetAllValidators_Call struct {
	*mock.Call
}

// GetAllValidators is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StakingKeeper_Expecter) GetAllValidators(ctx interface{}) *StakingKeeper_GetAllValidators_Call {
	return &StakingKeeper_GetAllValidators_Call{Call: _e.mock.On("GetAllValidators", ctx)}
}

func (_c *StakingKeeper_GetAllValidators_Call) Run(run func(ctx context.Context)) *StakingKeeper_GetAllValidators_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StakingKeeper_GetAllValidators_Call) Return(validators []stakingtypes.Validator, err error) *StakingKeeper_GetAllValidators_Call {
	_c.Call.Return(validators, err)
	return _c
}

func (_c *StakingKeeper_GetAllValidators_Call) RunAndReturn(run func(context.Context) ([]stakingtypes.Validator, error)) *StakingKeeper_GetAllValidators_Call {
	_c.Call.Return(run)
	return _c
}

// GetDelegation provides a mock function with given fields: ctx, delAddr, valAddr
func (_m *StakingKeeper) GetDelegation(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, valAddr cosmos_sdktypes.ValAddress) (stakingtypes.Delegation, error) {
	ret := _m.Called(ctx, delAddr, valAddr)

	if len(ret) == 0 {
		panic("no return value specified for GetDelegation")
	}

	var r0 stakingtypes.Delegation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) (stakingtypes.Delegation, error)); ok {
		return rf(ctx, delAddr, valAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) stakingtypes.Delegation); ok {
		r0 = rf(ctx, delAddr, valAddr)
	} else {
		r0 = ret.Get(0).(stakingtypes.Delegation)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) error); ok {
		r1 = rf(ctx, delAddr, valAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_GetDelegation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDelegation'
type StakingKeeper_GetDelegation_Call struct {
	*mock.Call
}

// GetDelegation is a helper method to define mock.On call
//   - ctx context.Context
//   - delAddr cosmos_sdktypes.AccAddress
//   - valAddr cosmos_sdktypes.ValAddress
func (_e *StakingKeeper_Expecter) GetDelegation(ctx interface{}, delAddr interface{}, valAddr interface{}) *StakingKeeper_GetDelegation_Call {
	return &StakingKeeper_GetDelegation_Call{Call: _e.mock.On("GetDelegation", ctx, delAddr, valAddr)}
}

func (_c *StakingKeeper_GetDelegation_Call) Run(run func(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, valAddr cosmos_sdktypes.ValAddress)) *StakingKeeper_GetDelegation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.AccAddress), args[2].(cosmos_sdktypes.ValAddress))
	})
	return _c
}

func (_c *StakingKeeper_GetDelegation_Call) Return(_a0 stakingtypes.Delegation, _a1 error) *StakingKeeper_GetDelegation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StakingKeeper_GetDelegation_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) (stakingtypes.Delegation, error)) *StakingKeeper_GetDelegation_Call {
	_c.Call.Return(run)
	return _c
}

// GetParams provides a mock function with given fields: ctx
func (_m *StakingKeeper) GetParams(ctx context.Context) (stakingtypes.Params, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetParams")
	}

	var r0 stakingtypes.Params
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (stakingtypes.Params, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) stakingtypes.Params); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(stakingtypes.Params)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_GetParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetParams'
type StakingKeeper_GetParams_Call struct {
	*mock.Call
}

// GetParams is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StakingKeeper_Expecter) GetParams(ctx interface{}) *StakingKeeper_GetParams_Call {
	return &StakingKeeper_GetParams_Call{Call: _e.mock.On("GetParams", ctx)}
}

func (_c *StakingKeeper_GetParams_Call) Run(run func(ctx context.Context)) *StakingKeeper_GetParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StakingKeeper_GetParams_Call) Return(params stakingtypes.Params, err error) *StakingKeeper_GetParams_Call {
	_c.Call.Return(params, err)
	return _c
}

func (_c *StakingKeeper_GetParams_Call) RunAndReturn(run func(context.Context) (stakingtypes.Params, error)) *StakingKeeper_GetParams_Call {
	_c.Call.Return(run)
	return _c
}

// GetValidator provides a mock function with given fields: ctx, addr
func (_m *StakingKeeper) GetValidator(ctx context.Context, addr cosmos_sdktypes.ValAddress) (stakingtypes.Validator, error) {
	ret := _m.Called(ctx, addr)

	if len(ret) == 0 {
		panic("no return value specified for GetValidator")
	}

	var r0 stakingtypes.Validator
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.ValAddress) (stakingtypes.Validator, error)); ok {
		return rf(ctx, addr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.ValAddress) stakingtypes.Validator); ok {
		r0 = rf(ctx, addr)
	} else {
		r0 = ret.Get(0).(stakingtypes.Validator)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.ValAddress) error); ok {
		r1 = rf(ctx, addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_GetValidator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValidator'
type StakingKeeper_GetValidator_Call struct {
	*mock.Call
}

// GetValidator is a helper method to define mock.On call
//   - ctx context.Context
//   - addr cosmos_sdktypes.ValAddress
func (_e *StakingKeeper_Expecter) GetValidator(ctx interface{}, addr interface{}) *StakingKeeper_GetValidator_Call {
	return &StakingKeeper_GetValidator_Call{Call: _e.mock.On("GetValidator", ctx, addr)}
}

func (_c *StakingKeeper_GetValidator_Call) Run(run func(ctx context.Context, addr cosmos_sdktypes.ValAddress)) *StakingKeeper_GetValidator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.ValAddress))
	})
	return _c
}

func (_c *StakingKeeper_GetValidator_Call) Return(validator stakingtypes.Validator, err error) *StakingKeeper_GetValidator_Call {
	_c.Call.Return(validator, err)
	return _c
}

func (_c *StakingKeeper_GetValidator_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.ValAddress) (stakingtypes.Validator, error)) *StakingKeeper_GetValidator_Call {
	_c.Call.Return(run)
	return _c
}

// GetValidatorDelegations provides a mock function with given fields: ctx, valAddr
func (_m *StakingKeeper) GetValidatorDelegations(ctx context.Context, valAddr cosmos_sdktypes.ValAddress) ([]stakingtypes.Delegation, error) {
	ret := _m.Called(ctx, valAddr)

	if len(ret) == 0 {
		panic("no return value specified for GetValidatorDelegations")
	}

	var r0 []stakingtypes.Delegation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.ValAddress) ([]stakingtypes.Delegation, error)); ok {
		return rf(ctx, valAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.ValAddress) []stakingtypes.Delegation); ok {
		r0 = rf(ctx, valAddr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]stakingtypes.Delegation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.ValAddress) error); ok {
		r1 = rf(ctx, valAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_GetValidatorDelegations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValidatorDelegations'
type StakingKeeper_GetValidatorDelegations_Call struct {
	*mock.Call
}

// GetValidatorDelegations is a helper method to define mock.On call
//   - ctx context.Context
//   - valAddr cosmos_sdktypes.ValAddress
func (_e *StakingKeeper_Expecter) GetValidatorDelegations(ctx interface{}, valAddr interface{}) *StakingKeeper_GetValidatorDelegations_Call {
	return &StakingKeeper_GetValidatorDelegations_Call{Call: _e.mock.On("GetValidatorDelegations", ctx, valAddr)}
}

func (_c *StakingKeeper_GetValidatorDelegations_Call) Run(run func(ctx context.Context, valAddr cosmos_sdktypes.ValAddress)) *StakingKeeper_GetValidatorDelegations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.ValAddress))
	})
	return _c
}

func (_c *StakingKeeper_GetValidatorDelegations_Call) Return(delegations []stakingtypes.Delegation, err error) *StakingKeeper_GetValidatorDelegations_Call {
	_c.Call.Return(delegations, err)
	return _c
}

func (_c *StakingKeeper_GetValidatorDelegations_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.ValAddress) ([]stakingtypes.Delegation, error)) *StakingKeeper_GetValidatorDelegations_Call {
	_c.Call.Return(run)
	return _c
}

// HasReceivingRedelegation provides a mock function with given fields: ctx, delAddr, valDstAddr
func (_m *StakingKeeper) HasReceivingRedelegation(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, valDstAddr cosmos_sdktypes.ValAddress) (bool, error) {
	ret := _m.Called(ctx, delAddr, valDstAddr)

	if len(ret) == 0 {
		panic("no return value specified for HasReceivingRedelegation")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) (bool, error)); ok {
		return rf(ctx, delAddr, valDstAddr)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) bool); ok {
		r0 = rf(ctx, delAddr, valDstAddr)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) error); ok {
		r1 = rf(ctx, delAddr, valDstAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_HasReceivingRedelegation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasReceivingRedelegation'
type StakingKeeper_HasReceivingRedelegation_Call struct {
	*mock.Call
}

// HasReceivingRedelegation is a helper method to define mock.On call
//   - ctx context.Context
//   - delAddr cosmos_sdktypes.AccAddress
//   - valDstAddr cosmos_sdktypes.ValAddress
func (_e *StakingKeeper_Expecter) HasReceivingRedelegation(ctx interface{}, delAddr interface{}, valDstAddr interface{}) *StakingKeeper_HasReceivingRedelegation_Call {
	return &StakingKeeper_HasReceivingRedelegation_Call{Call: _e.mock.On("HasReceivingRedelegation", ctx, delAddr, valDstAddr)}
}

func (_c *StakingKeeper_HasReceivingRedelegation_Call) Run(run func(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, valDstAddr cosmos_sdktypes.ValAddress)) *StakingKeeper_HasReceivingRedelegation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.AccAddress), args[2].(cosmos_sdktypes.ValAddress))
	})
	return _c
}

func (_c *StakingKeeper_HasReceivingRedelegation_Call) Return(_a0 bool, _a1 error) *StakingKeeper_HasReceivingRedelegation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StakingKeeper_HasReceivingRedelegation_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress) (bool, error)) *StakingKeeper_HasReceivingRedelegation_Call {
	_c.Call.Return(run)
	return _c
}

// SetValidator provides a mock function with given fields: ctx, validator
func (_m *StakingKeeper) SetValidator(ctx context.Context, validator stakingtypes.Validator) error {
	ret := _m.Called(ctx, validator)

	if len(ret) == 0 {
		panic("no return value specified for SetValidator")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, stakingtypes.Validator) error); ok {
		r0 = rf(ctx, validator)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StakingKeeper_SetValidator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetValidator'
type StakingKeeper_SetValidator_Call struct {
	*mock.Call
}

// SetValidator is a helper method to define mock.On call
//   - ctx context.Context
//   - validator stakingtypes.Validator
func (_e *StakingKeeper_Expecter) SetValidator(ctx interface{}, validator interface{}) *StakingKeeper_SetValidator_Call {
	return &StakingKeeper_SetValidator_Call{Call: _e.mock.On("SetValidator", ctx, validator)}
}

func (_c *StakingKeeper_SetValidator_Call) Run(run func(ctx context.Context, validator stakingtypes.Validator)) *StakingKeeper_SetValidator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(stakingtypes.Validator))
	})
	return _c
}

func (_c *StakingKeeper_SetValidator_Call) Return(_a0 error) *StakingKeeper_SetValidator_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StakingKeeper_SetValidator_Call) RunAndReturn(run func(context.Context, stakingtypes.Validator) error) *StakingKeeper_SetValidator_Call {
	_c.Call.Return(run)
	return _c
}

// TotalBondedTokens provides a mock function with given fields: ctx
func (_m *StakingKeeper) TotalBondedTokens(ctx context.Context) (math.Int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for TotalBondedTokens")
	}

	var r0 math.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (math.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) math.Int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(math.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_TotalBondedTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TotalBondedTokens'
type StakingKeeper_TotalBondedTokens_Call struct {
	*mock.Call
}

// TotalBondedTokens is a helper method to define mock.On call
//   - ctx context.Context
func (_e *StakingKeeper_Expecter) TotalBondedTokens(ctx interface{}) *StakingKeeper_TotalBondedTokens_Call {
	return &StakingKeeper_TotalBondedTokens_Call{Call: _e.mock.On("TotalBondedTokens", ctx)}
}

func (_c *StakingKeeper_TotalBondedTokens_Call) Run(run func(ctx context.Context)) *StakingKeeper_TotalBondedTokens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *StakingKeeper_TotalBondedTokens_Call) Return(_a0 math.Int, _a1 error) *StakingKeeper_TotalBondedTokens_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StakingKeeper_TotalBondedTokens_Call) RunAndReturn(run func(context.Context) (math.Int, error)) *StakingKeeper_TotalBondedTokens_Call {
	_c.Call.Return(run)
	return _c
}

// Unbond provides a mock function with given fields: ctx, delAddr, valAddr, shares
func (_m *StakingKeeper) Unbond(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, valAddr cosmos_sdktypes.ValAddress, shares math.LegacyDec) (math.Int, error) {
	ret := _m.Called(ctx, delAddr, valAddr, shares)

	if len(ret) == 0 {
		panic("no return value specified for Unbond")
	}

	var r0 math.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress, math.LegacyDec) (math.Int, error)); ok {
		return rf(ctx, delAddr, valAddr, shares)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress, math.LegacyDec) math.Int); ok {
		r0 = rf(ctx, delAddr, valAddr, shares)
	} else {
		r0 = ret.Get(0).(math.Int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress, math.LegacyDec) error); ok {
		r1 = rf(ctx, delAddr, valAddr, shares)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_Unbond_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unbond'
type StakingKeeper_Unbond_Call struct {
	*mock.Call
}

// Unbond is a helper method to define mock.On call
//   - ctx context.Context
//   - delAddr cosmos_sdktypes.AccAddress
//   - valAddr cosmos_sdktypes.ValAddress
//   - shares math.LegacyDec
func (_e *StakingKeeper_Expecter) Unbond(ctx interface{}, delAddr interface{}, valAddr interface{}, shares interface{}) *StakingKeeper_Unbond_Call {
	return &StakingKeeper_Unbond_Call{Call: _e.mock.On("Unbond", ctx, delAddr, valAddr, shares)}
}

func (_c *StakingKeeper_Unbond_Call) Run(run func(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, valAddr cosmos_sdktypes.ValAddress, shares math.LegacyDec)) *StakingKeeper_Unbond_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.AccAddress), args[2].(cosmos_sdktypes.ValAddress), args[3].(math.LegacyDec))
	})
	return _c
}

func (_c *StakingKeeper_Unbond_Call) Return(amount math.Int, err error) *StakingKeeper_Unbond_Call {
	_c.Call.Return(amount, err)
	return _c
}

func (_c *StakingKeeper_Unbond_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress, math.LegacyDec) (math.Int, error)) *StakingKeeper_Unbond_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateUnbondAmount provides a mock function with given fields: ctx, delAddr, valAddr, amt
func (_m *StakingKeeper) ValidateUnbondAmount(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, valAddr cosmos_sdktypes.ValAddress, amt math.Int) (math.LegacyDec, error) {
	ret := _m.Called(ctx, delAddr, valAddr, amt)

	if len(ret) == 0 {
		panic("no return value specified for ValidateUnbondAmount")
	}

	var r0 math.LegacyDec
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress, math.Int) (math.LegacyDec, error)); ok {
		return rf(ctx, delAddr, valAddr, amt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress, math.Int) math.LegacyDec); ok {
		r0 = rf(ctx, delAddr, valAddr, amt)
	} else {
		r0 = ret.Get(0).(math.LegacyDec)
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress, math.Int) error); ok {
		r1 = rf(ctx, delAddr, valAddr, amt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_ValidateUnbondAmount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateUnbondAmount'
type StakingKeeper_ValidateUnbondAmount_Call struct {
	*mock.Call
}

// ValidateUnbondAmount is a helper method to define mock.On call
//   - ctx context.Context
//   - delAddr cosmos_sdktypes.AccAddress
//   - valAddr cosmos_sdktypes.ValAddress
//   - amt math.Int
func (_e *StakingKeeper_Expecter) ValidateUnbondAmount(ctx interface{}, delAddr interface{}, valAddr interface{}, amt interface{}) *StakingKeeper_ValidateUnbondAmount_Call {
	return &StakingKeeper_ValidateUnbondAmount_Call{Call: _e.mock.On("ValidateUnbondAmount", ctx, delAddr, valAddr, amt)}
}

func (_c *StakingKeeper_ValidateUnbondAmount_Call) Run(run func(ctx context.Context, delAddr cosmos_sdktypes.AccAddress, valAddr cosmos_sdktypes.ValAddress, amt math.Int)) *StakingKeeper_ValidateUnbondAmount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.AccAddress), args[2].(cosmos_sdktypes.ValAddress), args[3].(math.Int))
	})
	return _c
}

func (_c *StakingKeeper_ValidateUnbondAmount_Call) Return(shares math.LegacyDec, err error) *StakingKeeper_ValidateUnbondAmount_Call {
	_c.Call.Return(shares, err)
	return _c
}

func (_c *StakingKeeper_ValidateUnbondAmount_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.AccAddress, cosmos_sdktypes.ValAddress, math.Int) (math.LegacyDec, error)) *StakingKeeper_ValidateUnbondAmount_Call {
	_c.Call.Return(run)
	return _c
}

// Validator provides a mock function with given fields: ctx, _a1
func (_m *StakingKeeper) Validator(ctx context.Context, _a1 cosmos_sdktypes.ValAddress) (stakingtypes.ValidatorI, error) {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Validator")
	}

	var r0 stakingtypes.ValidatorI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.ValAddress) (stakingtypes.ValidatorI, error)); ok {
		return rf(ctx, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, cosmos_sdktypes.ValAddress) stakingtypes.ValidatorI); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(stakingtypes.ValidatorI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, cosmos_sdktypes.ValAddress) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakingKeeper_Validator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Validator'
type StakingKeeper_Validator_Call struct {
	*mock.Call
}

// Validator is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 cosmos_sdktypes.ValAddress
func (_e *StakingKeeper_Expecter) Validator(ctx interface{}, _a1 interface{}) *StakingKeeper_Validator_Call {
	return &StakingKeeper_Validator_Call{Call: _e.mock.On("Validator", ctx, _a1)}
}

func (_c *StakingKeeper_Validator_Call) Run(run func(ctx context.Context, _a1 cosmos_sdktypes.ValAddress)) *StakingKeeper_Validator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(cosmos_sdktypes.ValAddress))
	})
	return _c
}

func (_c *StakingKeeper_Validator_Call) Return(_a0 stakingtypes.ValidatorI, _a1 error) *StakingKeeper_Validator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *StakingKeeper_Validator_Call) RunAndReturn(run func(context.Context, cosmos_sdktypes.ValAddress) (stakingtypes.ValidatorI, error)) *StakingKeeper_Validator_Call {
	_c.Call.Return(run)
	return _c
}

// ValidatorAddressCodec provides a mock function with given fields:
func (_m *StakingKeeper) ValidatorAddressCodec() address.Codec {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ValidatorAddressCodec")
	}

	var r0 address.Codec
	if rf, ok := ret.Get(0).(func() address.Codec); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(address.Codec)
		}
	}

	return r0
}

// StakingKeeper_ValidatorAddressCodec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidatorAddressCodec'
type StakingKeeper_ValidatorAddressCodec_Call struct {
	*mock.Call
}

// ValidatorAddressCodec is a helper method to define mock.On call
func (_e *StakingKeeper_Expecter) ValidatorAddressCodec() *StakingKeeper_ValidatorAddressCodec_Call {
	return &StakingKeeper_ValidatorAddressCodec_Call{Call: _e.mock.On("ValidatorAddressCodec")}
}

func (_c *StakingKeeper_ValidatorAddressCodec_Call) Run(run func()) *StakingKeeper_ValidatorAddressCodec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *StakingKeeper_ValidatorAddressCodec_Call) Return(_a0 address.Codec) *StakingKeeper_ValidatorAddressCodec_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *StakingKeeper_ValidatorAddressCodec_Call) RunAndReturn(run func() address.Codec) *StakingKeeper_ValidatorAddressCodec_Call {
	_c.Call.Return(run)
	return _c
}

// NewStakingKeeper creates a new instance of StakingKeeper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStakingKeeper(t interface {
	mock.TestingT
	Cleanup(func())
},
) *StakingKeeper {
	mock := &StakingKeeper{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
